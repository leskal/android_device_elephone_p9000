commit b695f13f92ddf6cdcb1bd9533563e02b74571020
Author: leskal <alexakis1997@gmail.com>
Date:   Wed May 10 17:46:35 2017 +0300

    location: implement mtk GNSS extension
    
    Change-Id: If2c02670617bc96c11b8b6a649f322b9e716bfd1

diff --git a/location/java/android/location/GpsStatus.java b/location/java/android/location/GpsStatus.java
index 323f326..dac30a4 100644
--- a/location/java/android/location/GpsStatus.java
+++ b/location/java/android/location/GpsStatus.java
@@ -20,6 +20,7 @@ import android.util.SparseArray;
 
 import java.util.Iterator;
 import java.util.NoSuchElementException;
+import android.os.SystemProperties;
 
 
 /**
@@ -27,6 +28,9 @@ import java.util.NoSuchElementException;
  * This class is used in conjunction with the {@link Listener} interface.
  */
 public final class GpsStatus {
+	// MTK workaround
+    private static final boolean MTKHardware = !(SystemProperties.get
+                                                 ("BOARD_MEDIATEK_USES_GPS", "").equals(""));
     private static final int NUM_SATELLITES = 255;
 
     /* These package private values are modified by the LocationManager class */
@@ -167,6 +171,43 @@ public final class GpsStatus {
         }
     }
 
+    if (MTKHardware) {
+		/**
+		 * Used internally within {@link LocationManager} to copy GPS status
+		 * data from the Location Manager Service to its cached GpsStatus instance.
+		 * Is synchronized to ensure that GPS status updates are atomic.
+		 *
+		 * This is modified to become aware of explicit GNSS support of &gt;32
+		 * satellites.
+		 */
+		synchronized void setStatusFromGnss(int gnssSvCount, int[] prns, float[] snrs,
+		        float[] elevations, float[] azimuths,
+		        boolean[] ephemerisPresences,
+		        boolean[] almanacPresences,
+		        boolean[] usedInFix) {
+					clearSatellites();
+					for (int i = 0; i < gnssSvCount; i++) {
+						int prn = prns[i] - 1;
+
+						if (prn >= 0 && prn < NUM_SATELLITES) {
+							GpsSatellite satellite = mSatellites.get(prn);
+							if (satellite == null) {
+								satellite = new GpsSatellite(prn);
+								mSatellites.put(prn, satellite);
+							}
+
+							satellite.mValid = true;
+							satellite.mSnr = snrs[i];
+							satellite.mElevation = elevations[i];
+							satellite.mAzimuth = azimuths[i];
+							satellite.mHasEphemeris = ephemerisPresences[i];
+							satellite.mHasAlmanac = almanacPresences[i];
+							satellite.mUsedInFix = usedInFix[i];
+						}
+					}
+				}
+	 }
+
     /**
      * Used by {@link LocationManager#getGpsStatus} to copy LocationManager's
      * cached GpsStatus instance to the client's copy.
diff --git a/location/java/android/location/IGpsStatusListener.aidl b/location/java/android/location/IGpsStatusListener.aidl
index 62b1c6b..7e19e3a 100644
--- a/location/java/android/location/IGpsStatusListener.aidl
+++ b/location/java/android/location/IGpsStatusListener.aidl
@@ -17,17 +17,28 @@
 package android.location;
 
 import android.location.Location;
+import android.os.SystemProperties;
 
 /**
  * {@hide}
  */
 oneway interface IGpsStatusListener
 {
+    // MTK workaround
+    private static final boolean MTKHardware = !(SystemProperties.get
+                                                 ("BOARD_MEDIATEK_USES_GPS", "").equals(""));
     void onGpsStarted();
     void onGpsStopped();
     void onFirstFix(int ttff);
-    void onSvStatusChanged(int svCount, in int[] prns, in float[] snrs, 
-            in float[] elevations, in float[] azimuths, 
+    void onSvStatusChanged(int svCount, in int[] prns, in float[] snrs,
+            in float[] elevations, in float[] azimuths,
             int ephemerisMask, int almanacMask, int usedInFixMask);
+   if (MTKHardware) {
+    void onGnssSvStatusChanged(int gnssSvCount, in int[] prns, in float[] snrs,
+            in float[] elevations, in float[] azimuths,
+            in boolean[] ephemerisPresences,
+            in boolean[] almanacPresences,
+            in boolean[] usedInFix);
+    }
     void onNmeaReceived(long timestamp, String nmea);
 }
diff --git a/location/java/android/location/LocationManager.java b/location/java/android/location/LocationManager.java
index 4544814..eac5a8c 100644
--- a/location/java/android/location/LocationManager.java
+++ b/location/java/android/location/LocationManager.java
@@ -29,6 +29,7 @@ import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
 import android.os.RemoteException;
+import android.os.SystemProperties;
 import android.util.Log;
 
 import java.util.ArrayList;
@@ -59,6 +60,9 @@ import static android.Manifest.permission.ACCESS_FINE_LOCATION;
  * location will be obfuscated to a coarse level of accuracy.
  */
 public class LocationManager {
+	// MTK workaround
+    private static final boolean MTKHardware = !(SystemProperties.get
+                                                 ("BOARD_MEDIATEK_USES_GPS", "").equals(""));
     private static final String TAG = "LocationManager";
 
     private final Context mContext;
@@ -1478,6 +1482,33 @@ public class LocationManager {
             }
         }
 
+        if (MTKHardware) {
+			@Override
+			public void onGnssSvStatusChanged(int gnssSvCount, int[] prns, float[] snrs,
+			        float[] elevations, float[] azimuths,
+			        boolean[] ephemerisPresences,
+			        boolean[] almanacPresences,
+			        boolean[] usedInFix) {
+						if (mListener != null) {
+							mGpsStatus.setStatusFromGnss(
+							        gnssSvCount,
+							        prns,
+							        snrs,
+							        elevations,
+							        azimuths,
+							        ephemerisPresences,
+							        almanacPresences,
+							        usedInFix);
+
+							Message msg = Message.obtain();
+							msg.what = GpsStatus.GPS_EVENT_SATELLITE_STATUS;
+							// remove any SV status messages already in the queue
+							mGpsHandler.removeMessages(GpsStatus.GPS_EVENT_SATELLITE_STATUS);
+							mGpsHandler.sendMessage(msg);
+						}
+					}
+        }
+
         @Override
         public void onNmeaReceived(long timestamp, String nmea) {
             if (mNmeaListener != null) {
diff --git a/services/core/java/com/android/server/location/GpsLocationProvider.java b/services/core/java/com/android/server/location/GpsLocationProvider.java
index 833c340..f369c9a 100644
--- a/services/core/java/com/android/server/location/GpsLocationProvider.java
+++ b/services/core/java/com/android/server/location/GpsLocationProvider.java
@@ -100,6 +100,9 @@ import libcore.io.IoUtils;
  * {@hide}
  */
 public class GpsLocationProvider implements LocationProviderInterface {
+	
+	private static final boolean MTKHardware = !(SystemProperties.get
+                                                 ("BOARD_MEDIATEK_USES_GPS", "").equals(""));
 
     private static final String TAG = "GpsLocationProvider";
 
@@ -1524,6 +1527,76 @@ public class GpsLocationProvider implements LocationProviderInterface {
         }
     }
 
+    if (MTKHardware) {
+		/**
+		 * Count number of GNSS satellites used in fix.
+		 *
+		 * We could not rely on Integer.bitCount as GNSS used-in-fix info is not
+		 * represented as a bit-mask.
+		*/
+		private int countGnssSvUsedInFix(final int gnssSvCount) {
+			int result = 0;
+
+			for (int i = 0; i < gnssSvCount; i++) {
+				if (mSvUsedInFix[i]) {
+					result++;
+				}
+			}
+
+			return result;
+
+		}
+
+		/**
+		 * called from native code to update GNSS SV info
+        */
+        private void reportGnssSvStatus() {
+			final int svCount = native_read_gnss_sv_status(
+			        mSvs,
+			        mSnrs,
+			        mSvElevations,
+			        mSvAzimuths,
+			        mSvEphemerisPresences,
+			        mSvAlmanacPresences,
+			        mSvUsedInFix);
+			mListenerHelper.onGnssSvStatusChanged(
+			        svCount,
+			        mSvs,
+			        mSnrs,
+			        mSvElevations,
+			        mSvAzimuths,
+			        mSvEphemerisPresences,
+			        mSvAlmanacPresences,
+			        mSvUsedInFix);
+
+			if (VERBOSE) {
+				Log.v(TAG, "GNSS SV count: " + svCount);
+				for (int i = 0; i < svCount; i++) {
+					Log.v(TAG, "sv: " + mSvs[i] +
+                            " snr: " + mSnrs[i]/10 +
+                            " elev: " + mSvElevations[i] +
+                            " azimuth: " + mSvAzimuths[i] +
+                            (!mSvEphemerisPresences[i] ? "  " : " E") +
+                            (!mSvAlmanacPresences[i] ? "  " : " A") +
+                            (!mSvUsedInFix[i] ? "" : "U"));
+                }
+            }
+
+            // return number of sets used in fix instead of total
+            updateStatus(mStatus, countGnssSvUsedInFix(svCount));
+
+            if (mNavigating && mStatus == LocationProvider.AVAILABLE && mLastFixTime > 0 &&
+                System.currentTimeMillis() - mLastFixTime > RECENT_FIX_TIMEOUT) {
+					// send an intent to notify that the GPS is no longer receiving fixes.
+					Intent intent = new Intent(LocationManager.GPS_FIX_CHANGE_ACTION);
+                    intent.putExtra(LocationManager.EXTRA_GPS_ENABLED, false);
+                    mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
+                    updateStatus(LocationProvider.TEMPORARILY_UNAVAILABLE, mSvCount);
+            }
+        }
+
+    }
+
     /**
      * called from native code to update AGPS status
      */
@@ -2257,12 +2330,29 @@ public class GpsLocationProvider implements LocationProviderInterface {
     private static final int ALMANAC_MASK = 1;
     private static final int USED_FOR_FIX_MASK = 2;
 
+    if (MTKHardware) {
+		// GNSS extension
+		private static final int MAX_GNSS_SVS = 256;
+    }
+
     // preallocated arrays, to avoid memory allocation in reportStatus()
-    private int mSvs[] = new int[MAX_SVS];
-    private float mSnrs[] = new float[MAX_SVS];
-    private float mSvElevations[] = new float[MAX_SVS];
-    private float mSvAzimuths[] = new float[MAX_SVS];
+    if (MTKHardware) {
+		private int mSvs[] = new int[MAX_GNSS_SVS];
+		private float mSnrs[] = new float[MAX_GNSS_SVS];
+		private float mSvElevations[] = new float[MAX_GNSS_SVS];
+		private float mSvAzimuths[] = new float[MAX_GNSS_SVS];
+	 } else {
+		 private int mSvs[] = new int[MAX_SVS];
+		 private float mSnrs[] = new float[MAX_SVS];
+		 private float mSvElevations[] = new float[MAX_SVS];
+		 private float mSvAzimuths[] = new float[MAX_SVS];
+    }
     private int mSvMasks[] = new int[3];
+    if (MTKHardware) {
+		private boolean mSvEphemerisPresences[] = new boolean[MAX_GNSS_SVS];
+		private boolean mSvAlmanacPresences[] = new boolean[MAX_GNSS_SVS];
+		private boolean mSvUsedInFix[] = new boolean[MAX_GNSS_SVS];
+    }
     private int mSvCount;
     // preallocated to avoid memory allocation in reportNmea()
     private byte[] mNmeaBuffer = new byte[120];
@@ -2284,6 +2374,14 @@ public class GpsLocationProvider implements LocationProviderInterface {
     // mask[0] is ephemeris mask and mask[1] is almanac mask
     private native int native_read_sv_status(int[] svs, float[] snrs,
             float[] elevations, float[] azimuths, int[] masks);
+    if (MTKHardware) {
+		// returns number of GNSS SVs
+		private native int native_read_gnss_sv_status(int[] svs, float[] snrs,
+                float[] elevations, float[] azimuths,
+                boolean[] ephemerisPresences,
+                boolean[] almanacPresences,
+                boolean[] usedInFix);
+    }
     private native int native_read_nmea(byte[] buffer, int bufferSize);
     private native void native_inject_location(double latitude, double longitude, float accuracy);
 
@@ -2335,4 +2433,3 @@ public class GpsLocationProvider implements LocationProviderInterface {
     // GNSS Configuration
     private static native void native_configuration_update(String configData);
 }
-
diff --git a/services/core/java/com/android/server/location/GpsStatusListenerHelper.java b/services/core/java/com/android/server/location/GpsStatusListenerHelper.java
index 53ff6c2..9eb5c17 100644
--- a/services/core/java/com/android/server/location/GpsStatusListenerHelper.java
+++ b/services/core/java/com/android/server/location/GpsStatusListenerHelper.java
@@ -19,11 +19,15 @@ package com.android.server.location;
 import android.location.IGpsStatusListener;
 import android.os.Handler;
 import android.os.RemoteException;
+import android.os.SystemProperties;
 
 /**
  * Implementation of a handler for {@link IGpsStatusListener}.
  */
 abstract class GpsStatusListenerHelper extends RemoteListenerHelper<IGpsStatusListener> {
+	private static final boolean MTKHardware = !(SystemProperties.get
+                                                 ("BOARD_MEDIATEK_USES_GPS", "").equals(""));
+	
     protected GpsStatusListenerHelper(Handler handler) {
         super(handler, "GpsStatusListenerHelper");
         setSupported(GpsLocationProvider.isSupported());
@@ -98,6 +102,34 @@ abstract class GpsStatusListenerHelper extends RemoteListenerHelper<IGpsStatusLi
         foreach(operation);
     }
 
+    if (MTKHardware) {
+		public void onGnssSvStatusChanged(
+		        final int svCount,
+                final int[] prns,
+                final float[] snrs,
+                final float[] elevations,
+                final float[] azimuths,
+                final boolean[] ephemerisPresences,
+                final boolean[] almanacPresences,
+                final boolean[] usedInFix) {
+            Operation operation = new Operation() {
+				@Override
+                public void execute(IGpsStatusListener listener) throws RemoteException {
+					listener.onGnssSvStatusChanged(
+                            svCount,
+                            prns,
+                            snrs,
+                            elevations,
+                            azimuths,
+                            ephemerisPresences,
+                            almanacPresences,
+                            usedInFix);
+                }
+            };
+            foreach(operation);
+        }
+    }
+
     public void onNmeaReceived(final long timestamp, final String nmea) {
         Operation operation = new Operation() {
             @Override
diff --git a/services/core/jni/com_android_server_location_GpsLocationProvider.cpp b/services/core/jni/com_android_server_location_GpsLocationProvider.cpp
index 91eeb8b..ae0a7e6 100644
--- a/services/core/jni/com_android_server_location_GpsLocationProvider.cpp
+++ b/services/core/jni/com_android_server_location_GpsLocationProvider.cpp
@@ -21,7 +21,11 @@
 #include "JNIHelp.h"
 #include "jni.h"
 #include "hardware/hardware.h"
+#ifndef MTK_GPS_GNSS
 #include "hardware/gps.h"
+#else
+#include "hardware/gps_mtk.h"
+#endif
 #include "hardware_legacy/power.h"
 #include "utils/Log.h"
 #include "utils/misc.h"
@@ -39,6 +43,9 @@ static jobject mCallbacksObj = NULL;
 static jmethodID method_reportLocation;
 static jmethodID method_reportStatus;
 static jmethodID method_reportSvStatus;
+#ifdef MTK_GPS_GNSS
+static jmethodID method_reportGnssSvStatus;
+#endif
 static jmethodID method_reportAGpsStatus;
 static jmethodID method_reportNmea;
 static jmethodID method_setEngineCapabilities;
@@ -69,6 +76,9 @@ static const GnssConfigurationInterface* sGnssConfigurationInterface = NULL;
 
 // temporary storage for GPS callbacks
 static GpsSvStatus  sGpsSvStatus;
+#ifdef MTK_GPS_GNSS
+static GnssSvStatus  sGnssSvStatus;
+#endif
 static const char* sNmeaString;
 static int sNmeaStringLength;
 
@@ -110,6 +120,16 @@ static void sv_status_callback(GpsSvStatus* sv_status)
     checkAndClearExceptionFromCallback(env, __FUNCTION__);
 }
 
+#ifdef MTK_GPS_GNSS
+static void gnss_sv_status_callback(GnssSvStatus* sv_status)
+{
+    JNIEnv* env = AndroidRuntime::getJNIEnv();
+    memcpy(&sGnssSvStatus, sv_status, sizeof(sGnssSvStatus));
+    env->CallVoidMethod(mCallbacksObj, method_reportGnssSvStatus);
+    checkAndClearExceptionFromCallback(env, __FUNCTION__);
+}
+#endif
+
 static void nmea_callback(GpsUtcTime timestamp, const char* nmea, int length)
 {
     JNIEnv* env = AndroidRuntime::getJNIEnv();
@@ -151,8 +171,13 @@ static pthread_t create_thread_callback(const char* name, void (*start)(void *),
     return (pthread_t)AndroidRuntime::createJavaThread(name, start, arg);
 }
 
-GpsCallbacks sGpsCallbacks = {
-    sizeof(GpsCallbacks),
+#ifndef MTK_GPS_GNSS
+ GpsCallbacks sGpsCallbacks = {
+	 sizeof(GpsCallbacks),
+#else
+ GpsCallbacks_mtk sGpsCallbacks = {
+	 sizeof(GpsCallbacks_mtk),
+#endif
     location_callback,
     status_callback,
     sv_status_callback,
@@ -162,6 +187,10 @@ GpsCallbacks sGpsCallbacks = {
     release_wakelock_callback,
     create_thread_callback,
     request_utc_time_callback,
+#ifdef MTK_GPS_GNSS
+    // MTK
+    gnss_sv_status_callback,
+#endif
 };
 
 static void xtra_download_request_callback()
@@ -446,6 +475,9 @@ static void android_location_GpsLocationProvider_class_init_native(JNIEnv* env,
     method_reportLocation = env->GetMethodID(clazz, "reportLocation", "(IDDDFFFJ)V");
     method_reportStatus = env->GetMethodID(clazz, "reportStatus", "(I)V");
     method_reportSvStatus = env->GetMethodID(clazz, "reportSvStatus", "()V");
+#ifdef MTK_GPS_GNSS
+    method_reportGnssSvStatus = env->GetMethodID(clazz, "reportGnssSvStatus", "()V");
+#endif
     method_reportAGpsStatus = env->GetMethodID(clazz, "reportAGpsStatus", "(II[B)V");
     method_reportNmea = env->GetMethodID(clazz, "reportNmea", "(J)V");
     method_setEngineCapabilities = env->GetMethodID(clazz, "setEngineCapabilities", "(I)V");
@@ -534,7 +566,11 @@ static jboolean android_location_GpsLocationProvider_init(JNIEnv* env, jobject o
         mCallbacksObj = env->NewGlobalRef(obj);
 
     // fail if the main interface fails to initialize
+#ifndef MTK_GPS_GNSS
     if (!sGpsInterface || sGpsInterface->init(&sGpsCallbacks) != 0)
+#else
+    if (!sGpsInterface || sGpsInterface->init((GpsCallbacks*)&sGpsCallbacks) != 0)
+#endif
         return JNI_FALSE;
 
     // if XTRA initialization fails we will disable it by sGpsXtraInterface to NULL,
@@ -640,6 +676,46 @@ static jint android_location_GpsLocationProvider_read_sv_status(JNIEnv* env, job
     return (jint) num_svs;
 }
 
+#ifdef MTK_GPS_GNSS
+static jint android_location_GpsLocationProvider_read_gnss_sv_status(JNIEnv* env, jobject obj,
+        jintArray prnArray, jfloatArray snrArray, jfloatArray elevArray, jfloatArray azumArray,
+        jbooleanArray ephemerisPresencesArray,
+        jbooleanArray almanacPresencesArray,
+        jbooleanArray usedInFixArray)
+{
+    // this should only be called from within a call to reportGnssSvStatus
+
+    jint* prns = env->GetIntArrayElements(prnArray, 0);
+    jfloat* snrs = env->GetFloatArrayElements(snrArray, 0);
+    jfloat* elev = env->GetFloatArrayElements(elevArray, 0);
+    jfloat* azim = env->GetFloatArrayElements(azumArray, 0);
+    jboolean* ephemeris_presences = env->GetBooleanArrayElements(ephemerisPresencesArray, 0);
+    jboolean* almanac_presences = env->GetBooleanArrayElements(almanacPresencesArray, 0);
+    jboolean* used_in_fix = env->GetBooleanArrayElements(usedInFixArray, 0);
+
+    int num_svs = sGnssSvStatus.num_svs;
+    for (int i = 0; i < num_svs; i++) {
+        prns[i] = sGnssSvStatus.sv_list[i].prn;
+        snrs[i] = sGnssSvStatus.sv_list[i].snr;
+        elev[i] = sGnssSvStatus.sv_list[i].elevation;
+        azim[i] = sGnssSvStatus.sv_list[i].azimuth;
+
+        ephemeris_presences[i] = sGnssSvStatus.sv_list[i].has_ephemeris ? 1 : 0;
+        almanac_presences[i] = sGnssSvStatus.sv_list[i].has_almanac ? 1 : 0;
+        used_in_fix[i] = sGnssSvStatus.sv_list[i].used_in_fix ? 1 : 0;
+    }
+
+    env->ReleaseIntArrayElements(prnArray, prns, 0);
+    env->ReleaseFloatArrayElements(snrArray, snrs, 0);
+    env->ReleaseFloatArrayElements(elevArray, elev, 0);
+    env->ReleaseFloatArrayElements(azumArray, azim, 0);
+    env->ReleaseBooleanArrayElements(ephemerisPresencesArray, ephemeris_presences, 0);
+    env->ReleaseBooleanArrayElements(almanacPresencesArray, almanac_presences, 0);
+    env->ReleaseBooleanArrayElements(usedInFixArray, used_in_fix, 0);
+    return (jint) num_svs;
+}
+#endif
+
 static void android_location_GpsLocationProvider_agps_set_reference_location_cellid(
         JNIEnv* /* env */, jobject /* obj */, jint type, jint mcc, jint mnc, jint lac, jint cid, jint psc)
 {
@@ -1460,6 +1536,11 @@ static JNINativeMethod sMethods[] = {
     {"native_read_sv_status",
             "([I[F[F[F[I)I",
             (void*)android_location_GpsLocationProvider_read_sv_status},
+#ifdef MTK_GPS_GNSS
+    {"native_read_gnss_sv_status",
+            "([I[F[F[F[Z[Z[Z)I",
+            (void*)android_location_GpsLocationProvider_read_gnss_sv_status},
+#endif
     {"native_read_nmea", "([BI)I", (void*)android_location_GpsLocationProvider_read_nmea},
     {"native_inject_time", "(JJI)V", (void*)android_location_GpsLocationProvider_inject_time},
     {"native_inject_location",
